<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dance Viewer</title>
    <style>
        :root {
            --module-scale: 1;
        }

        body.resolution-4k {
            --module-scale: 2;
            transform: scale(2);
            transform-origin: top left;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: calc(8px * var(--module-scale)) calc(12px * var(--module-scale));
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: calc(15px * var(--module-scale));
        }

        .dance-selector {
            padding: calc(6px * var(--module-scale)) calc(10px * var(--module-scale));
            font-size: calc(14px * var(--module-scale));
            border: 1px solid #667eea;
            border-radius: calc(4px * var(--module-scale));
            background: white;
            color: #2c3e50;
            cursor: pointer;
            transition: border-color 0.2s;
            min-width: calc(180px * var(--module-scale));
        }

        .dance-selector:hover {
            border-color: #764ba2;
        }

        .dance-selector:focus {
            outline: none;
            border-color: #764ba2;
        }

        .dance-title {
            font-size: calc(16px * var(--module-scale));
            font-weight: bold;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: calc(8px * var(--module-scale));
            flex-shrink: 0;
        }

        .play-btn {
            width: calc(32px * var(--module-scale));
            height: calc(32px * var(--module-scale));
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
            flex-shrink: 0;
        }

        .play-btn:hover {
            transform: scale(1.05);
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .play-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn {
            width: calc(28px * var(--module-scale));
            height: calc(28px * var(--module-scale));
            border-radius: calc(4px * var(--module-scale));
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
            flex-shrink: 0;
            font-size: calc(11px * var(--module-scale));
            color: white;
            font-weight: bold;
        }

        .control-btn:hover {
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .speed-btn {
            width: calc(36px * var(--module-scale));
            height: calc(28px * var(--module-scale));
            border-radius: calc(4px * var(--module-scale));
            background: white;
            border: 2px solid #667eea;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            flex-shrink: 0;
            font-size: calc(10px * var(--module-scale));
            color: #667eea;
            font-weight: bold;
        }

        .speed-btn:hover {
            transform: scale(1.05);
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .speed-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .play-icon, .pause-icon {
            width: calc(14px * var(--module-scale));
            height: calc(14px * var(--module-scale));
            fill: white;
        }

        .pause-icon {
            display: none;
        }

        .play-btn.playing .play-icon {
            display: none;
        }

        .play-btn.playing .pause-icon {
            display: block;
        }

        .progress-container {
            flex: 1;
            max-width: calc(250px * var(--module-scale));
            height: calc(8px * var(--module-scale));
            background: #e0e0e0;
            border-radius: calc(4px * var(--module-scale));
            overflow: hidden;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            width: 0%;
            transition: width 0.1s linear;
        }

        .time-display {
            font-size: calc(11px * var(--module-scale));
            color: #666;
            min-width: calc(60px * var(--module-scale));
            text-align: right;
            white-space: nowrap;
        }

        .dance-chart-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: calc(15px * var(--module-scale));
        }

        .section {
            background: white;
            border-radius: calc(10px * var(--module-scale));
            padding: calc(12px * var(--module-scale));
            margin-bottom: calc(12px * var(--module-scale));
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: calc(10px * var(--module-scale));
            align-items: center;
        }

        .section-letter {
            font-size: calc(56px * var(--module-scale));
            font-weight: bold;
            color: #2c3e50;
            padding: calc(10px * var(--module-scale));
            text-align: center;
            width: calc(80px * var(--module-scale));
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: calc(8px * var(--module-scale));
        }

        .beat-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: calc(6px * var(--module-scale));
            align-items: start;
        }

        .repeat-start {
            font-size: calc(36px * var(--module-scale));
            font-weight: bold;
            color: #333;
            padding: 0 calc(5px * var(--module-scale));
            display: flex;
            align-items: center;
            align-self: stretch;
        }

        .beat-rows {
            display: flex;
            flex-direction: column;
            gap: calc(4px * var(--module-scale));
        }

        .beat-row {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: calc(3px * var(--module-scale));
        }

        .beat-box {
            min-width: calc(60px * var(--module-scale));
            height: calc(60px * var(--module-scale));
            border: calc(2px * var(--module-scale)) solid #333;
            border-radius: calc(4px * var(--module-scale));
            display: flex;
            align-items: center;
            justify-content: center;
            color: #222;
            padding: calc(4px * var(--module-scale));
            text-align: center;
            word-wrap: break-word;
            line-height: 1;
            font-weight: bold;
            overflow: hidden;
            transition: all 0.1s;
        }

        .beat-box.highlighted {
            border: calc(4px * var(--module-scale)) solid #ff6b6b;
            box-shadow: 0 0 calc(15px * var(--module-scale)) rgba(255, 107, 107, 0.6);
            transform: scale(1.05);
        }

        .metronome-btn {
            width: calc(50px * var(--module-scale));
            height: calc(28px * var(--module-scale));
            border-radius: calc(4px * var(--module-scale));
            background: white;
            border: 2px solid #ff9800;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            flex-shrink: 0;
            font-size: calc(11px * var(--module-scale));
            color: #ff9800;
            font-weight: bold;
            margin-right: calc(4px * var(--module-scale));
        }

        .metronome-btn:hover {
            transform: scale(1.05);
        }

        .metronome-btn.active {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
        }

        .metronome-stop {
            background: white;
            border-color: #e53935;
            color: #e53935;
        }

        .metronome-stop.active {
            background: linear-gradient(135deg, #e53935 0%, #c62828 100%);
            color: white;
        }

        .repeat-end {
            font-size: calc(36px * var(--module-scale));
            font-weight: bold;
            color: #333;
            padding-left: calc(5px * var(--module-scale));
            display: flex;
            align-items: center;
        }

        .speaker-icon {
            width: calc(40px * var(--module-scale));
            height: calc(40px * var(--module-scale));
            opacity: 0.6;
        }

        .section-note {
            font-size: calc(18px * var(--module-scale));
            font-style: italic;
            color: #555;
            text-align: center;
            margin-top: calc(8px * var(--module-scale));
            grid-column: 1 / -1;
        }

        .error-message {
            text-align: center;
            padding: calc(40px * var(--module-scale));
            color: #721c24;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: calc(8px * var(--module-scale));
            margin: calc(20px * var(--module-scale));
        }

        /* Scrollbar styling */
        .dance-chart-container::-webkit-scrollbar {
            width: calc(10px * var(--module-scale));
        }

        .dance-chart-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .dance-chart-container::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: calc(5px * var(--module-scale));
        }

        .dance-chart-container::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.8);
        }
    </style>
</head>
<body>
    <div class="header">
        <select class="dance-selector" id="danceSelector">
            <option value="">Loading dances...</option>
        </select>

        <button class="metronome-btn" id="metro65Btn" title="65 BPM Metronome">65</button>
        <button class="metronome-btn" id="metro85Btn" title="85 BPM Metronome">85</button>
        <button class="metronome-btn" id="metro95Btn" title="95 BPM Metronome">95</button>
        <button class="metronome-btn metronome-stop" id="metroStopBtn" title="Stop Metronome">STOP</button>

        <div class="dance-title" id="danceTitle">Select a dance to begin</div>

        <button class="play-btn" id="playBtn" disabled>
            <svg class="play-icon" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
            </svg>
            <svg class="pause-icon" viewBox="0 0 24 24">
                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
            </svg>
        </button>

        <button class="control-btn" id="restartBtn" disabled title="Restart">‚Ü∫</button>
        <button class="control-btn" id="backBtn" disabled title="Back 10 seconds">-10</button>
        <button class="control-btn" id="forwardBtn" disabled title="Forward 10 seconds">+10</button>

        <button class="speed-btn" id="speed90Btn" disabled title="90% speed">90%</button>
        <button class="speed-btn" id="speed95Btn" disabled title="95% speed">95%</button>
        <button class="speed-btn active" id="speed100Btn" disabled title="100% speed">100%</button>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
    </div>

    <div class="dance-chart-container" id="danceChartContainer">
        <!-- Dance sections will be rendered here -->
    </div>

    <audio id="danceAudio" preload="auto"></audio>

    <script>
        // Detect 4K resolution and apply scaling
        if (window.screen.width >= 3840 || window.screen.height >= 2160) {
            document.body.classList.add('resolution-4k');
        }

        let currentDance = null;
        let audioElement = null;
        let availableDances = [];
        let currentBlobURL = null;
        let audioListenersInitialized = false;

        // Metronome state
        let metronomeInterval = null;
        let metronomeBPM = null;
        let beatBoxes = [];
        let currentBeatIndex = -1;
        let countdownBeats = 0;
        let audioContext = null;

        // Initialize audio context for metronome clicks
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        // Play metronome click sound
        function playMetronomeClick(isDownbeat = false) {
            const ctx = initAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            // Higher pitch for downbeat (first beat), lower for others
            oscillator.frequency.value = isDownbeat ? 1200 : 800;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.1);
        }

        // Play countdown click (different sound)
        function playCountdownClick() {
            const ctx = initAudioContext();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.frequency.value = 600; // Lower pitch for countdown
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);

            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.08);
        }

        window.TaskModule = {
            async init(context) {
                console.log('Dance Viewer init with context:', context);

                try {
                    console.log('About to call getDances()...');
                    // Get the list of available dances from parent app
                    const dances = await window.parent.app.getDances();
                    console.log('getDances() call completed');
                    console.log('Received dances from parent:', dances);
                    console.log('Type of dances:', typeof dances);
                    console.log('Is array?', Array.isArray(dances));

                    if (!dances) {
                        throw new Error('getDances() returned null or undefined');
                    }

                    if (dances.length === 0) {
                        const selector = document.getElementById('danceSelector');
                        selector.innerHTML = '<option value="">No dances found - check dances.csv exists in data folder</option>';
                        this.showError('No dances found in dances.csv. Make sure the file exists in your data folder with dance entries.');
                        return;
                    }

                    // Populate the dropdown with the dances
                    this.populateDanceSelector(dances);

                    // Set up the dance selector change handler
                    const selector = document.getElementById('danceSelector');
                    selector.addEventListener('change', async (e) => {
                        const danceId = e.target.value;
                        if (danceId) {
                            await this.loadAndDisplayDance(danceId);
                        }
                    });

                    // Set up metronome button handlers
                    document.getElementById('metro65Btn').addEventListener('click', () => this.startMetronome(65));
                    document.getElementById('metro85Btn').addEventListener('click', () => this.startMetronome(85));
                    document.getElementById('metro95Btn').addEventListener('click', () => this.startMetronome(95));
                    document.getElementById('metroStopBtn').addEventListener('click', () => this.stopMetronome());

                } catch (error) {
                    console.error('Error initializing dance viewer:', error);
                    const selector = document.getElementById('danceSelector');
                    selector.innerHTML = '<option value="">Error: ' + error.message + '</option>';
                    this.showError('Failed to load dances: ' + error.message);
                }
            },

            async loadAndDisplayDance(danceId) {
                try {
                    // Load dance from parent app
                    const danceJson = await window.parent.app.loadDance(danceId);
                    currentDance = JSON.parse(danceJson);

                    console.log('Loaded dance:', currentDance);

                    // Render the dance
                    this.renderDance(currentDance);

                    // Load audio
                    await this.loadAudio(currentDance.audioFile);

                } catch (error) {
                    console.error('Error loading dance:', error);
                    this.showError(error.message);
                }
            },

            populateDanceSelector(dances) {
                console.log('Populating dance selector with:', dances);
                const selector = document.getElementById('danceSelector');
                selector.innerHTML = '<option value="">-- Select a Dance --</option>';

                if (!dances || dances.length === 0) {
                    selector.innerHTML = '<option value="">No dances available</option>';
                    this.showError('No dances found in dances.csv');
                    return;
                }

                dances.forEach(dance => {
                    if (dance && dance.id && dance.title) {
                        const option = document.createElement('option');
                        option.value = dance.id;
                        option.textContent = dance.title;
                        selector.appendChild(option);
                    }
                });

                availableDances = dances;

                // Auto-select first dance if available
                if (dances.length > 0 && dances[0].id) {
                    selector.value = dances[0].id;
                    // Don't await here - let it load in background
                    this.loadAndDisplayDance(dances[0].id).catch(err => {
                        console.error('Error auto-loading first dance:', err);
                    });
                }
            },

            renderDance(dance) {
                // Set title (subtitle removed to save space)
                document.getElementById('danceTitle').textContent = dance.title || 'Untitled Dance';

                // Render sections
                const container = document.getElementById('danceChartContainer');
                container.innerHTML = '';

                if (!dance.sections || dance.sections.length === 0) {
                    container.innerHTML = '<div class="error-message">No sections defined for this dance.</div>';
                    return;
                }

                dance.sections.forEach(section => {
                    const sectionEl = this.createSectionElement(section);
                    container.appendChild(sectionEl);
                });

                // Dynamically size text in all beat boxes after rendering
                // Use requestAnimationFrame to ensure DOM layout is complete
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        this.autoSizeBeatBoxText();
                    });
                });
            },

            autoSizeBeatBoxText() {
                const beatBoxes = document.querySelectorAll('.beat-box');
                console.log(`\n=== RESIZING ${beatBoxes.length} BEAT BOXES ===`);

                beatBoxes.forEach((box, index) => {
                    const text = box.textContent.trim();
                    if (!text) {
                        console.log(`Box ${index}: empty, skipping`);
                        return;
                    }

                    console.log(`\n--- Box ${index}: "${text}" ---`);

                    // Get box dimensions
                    const boxWidth = box.offsetWidth;
                    const boxHeight = box.offsetHeight;

                    if (boxWidth === 0 || boxHeight === 0) {
                        console.warn(`Box has zero dimensions, skipping`);
                        return;
                    }

                    console.log(`Box outer dimensions: ${boxWidth}x${boxHeight}px`);

                    // Get padding and border from computed style
                    const computedStyle = window.getComputedStyle(box);
                    const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
                    const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
                    const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                    const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                    const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
                    const borderBottom = parseFloat(computedStyle.borderBottomWidth) || 0;
                    const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
                    const borderRight = parseFloat(computedStyle.borderRightWidth) || 0;

                    console.log(`Padding: T=${paddingTop} R=${paddingRight} B=${paddingBottom} L=${paddingLeft}`);
                    console.log(`Border: T=${borderTop} R=${borderRight} B=${borderBottom} L=${borderLeft}`);

                    // Calculate available space - be less aggressive with margins
                    const availableWidth = boxWidth - paddingLeft - paddingRight - borderLeft - borderRight - 2;
                    const availableHeight = boxHeight - paddingTop - paddingBottom - borderTop - borderBottom - 2;

                    console.log(`Available: ${availableWidth.toFixed(1)}x${availableHeight.toFixed(1)}px`);

                    if (availableWidth < 10 || availableHeight < 10) {
                        console.error(`Available space too small! Check CSS - boxes may be collapsed.`);
                        return;
                    }

                    // Create temporary span to measure text
                    const measurer = document.createElement('span');
                    measurer.style.cssText = `
                        position: absolute;
                        visibility: hidden;
                        white-space: nowrap;
                        font-weight: bold;
                        font-family: Arial, sans-serif;
                        line-height: 1;
                        padding: 0;
                        margin: 0;
                    `;
                    measurer.textContent = text;
                    document.body.appendChild(measurer);

                    // Binary search for optimal font size
                    let minSize = 10;
                    let maxSize = Math.min(120, availableHeight * 1.2); // Cap based on available height
                    let bestSize = minSize;
                    let iterations = 0;

                    console.log(`Starting binary search: ${minSize}px to ${maxSize.toFixed(1)}px`);

                    while (maxSize - minSize > 0.5 && iterations < 30) {
                        const testSize = (minSize + maxSize) / 2;
                        measurer.style.fontSize = testSize + 'px';

                        // Force layout
                        const textWidth = measurer.offsetWidth;
                        const textHeight = measurer.offsetHeight;

                        const fitsWidth = textWidth <= availableWidth;
                        const fitsHeight = textHeight <= availableHeight;
                        const fits = fitsWidth && fitsHeight;

                        if (iterations < 8) { // Log first several iterations
                            console.log(`  [${iterations}] ${testSize.toFixed(1)}px: ${textWidth.toFixed(0)}x${textHeight.toFixed(0)} vs ${availableWidth.toFixed(0)}x${availableHeight.toFixed(0)} => ${fits ? '‚úì FITS' : '‚úó TOO BIG'}`);
                        }

                        if (fits) {
                            bestSize = testSize;
                            minSize = testSize;
                        } else {
                            maxSize = testSize;
                        }

                        iterations++;
                    }

                    document.body.removeChild(measurer);

                    // Apply the final size
                    box.style.setProperty('font-size', bestSize + 'px', 'important');
                    box.style.setProperty('line-height', '1', 'important');

                    console.log(`‚úì‚úì‚úì Box ${index} "${text}": FINAL SIZE = ${bestSize.toFixed(1)}px (${iterations} iterations) ‚úì‚úì‚úì`);
                });

                console.log(`\n=== RESIZING COMPLETE ===\n`);
            },

            createSectionElement(section) {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section';

                // Section letter
                const letterDiv = document.createElement('div');
                letterDiv.className = 'section-letter';
                letterDiv.textContent = section.letter || '?';
                sectionDiv.appendChild(letterDiv);

                // Section content (beat grid)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'section-content';

                const beatGrid = document.createElement('div');
                beatGrid.className = 'beat-grid';

                // Repeat start marker (if repeats)
                if (section.repeats) {
                    const repeatStart = document.createElement('div');
                    repeatStart.className = 'repeat-start';
                    repeatStart.innerHTML = 'ùÑÜ'; // Unicode repeat start symbol
                    beatGrid.appendChild(repeatStart);
                } else {
                    beatGrid.appendChild(document.createElement('div')); // Empty spacer
                }

                // Beat rows
                const beatRows = document.createElement('div');
                beatRows.className = 'beat-rows';

                if (section.rows && section.rows.length > 0) {
                    section.rows.forEach(row => {
                        const rowDiv = document.createElement('div');
                        rowDiv.className = 'beat-row';

                        // Each row should have 8 beats
                        for (let i = 0; i < 8; i++) {
                            const beatBox = document.createElement('div');
                            beatBox.className = 'beat-box';
                            beatBox.style.backgroundColor = section.color || '#f0f0f0';
                            beatBox.textContent = row[i] || '';
                            rowDiv.appendChild(beatBox);
                        }

                        beatRows.appendChild(rowDiv);
                    });
                } else {
                    beatRows.innerHTML = '<div class="error-message">No beats defined for this section.</div>';
                }

                beatGrid.appendChild(beatRows);
                contentDiv.appendChild(beatGrid);

                // Section note (if present)
                if (section.note) {
                    const noteDiv = document.createElement('div');
                    noteDiv.className = 'section-note';
                    noteDiv.textContent = section.note;
                    contentDiv.appendChild(noteDiv);
                }

                sectionDiv.appendChild(contentDiv);

                // Decorative speaker icon on right (if repeats)
                if (section.repeats) {
                    const repeatEnd = document.createElement('div');
                    repeatEnd.className = 'repeat-end';
                    repeatEnd.innerHTML = 'ùÑá'; // Unicode repeat end symbol
                    sectionDiv.appendChild(repeatEnd);
                } else {
                    // Decorative speaker icon (non-functional)
                    const speakerDiv = document.createElement('div');
                    speakerDiv.innerHTML = `
                        <svg class="speaker-icon" viewBox="0 0 24 24" fill="#666">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    `;
                    sectionDiv.appendChild(speakerDiv);
                }

                return sectionDiv;
            },

            setupAudioEventListeners() {
                // Only set up event listeners once
                if (audioListenersInitialized) {
                    return;
                }

                const playBtn = document.getElementById('playBtn');
                const restartBtn = document.getElementById('restartBtn');
                const backBtn = document.getElementById('backBtn');
                const forwardBtn = document.getElementById('forwardBtn');
                const speed90Btn = document.getElementById('speed90Btn');
                const speed95Btn = document.getElementById('speed95Btn');
                const speed100Btn = document.getElementById('speed100Btn');
                const progressBar = document.getElementById('progressBar');
                const progressContainer = document.getElementById('progressContainer');
                const timeDisplay = document.getElementById('timeDisplay');

                // Enable controls when audio is loaded
                audioElement.addEventListener('canplay', () => {
                    console.log('Audio canplay event - enabling controls');
                    playBtn.disabled = false;
                    restartBtn.disabled = false;
                    backBtn.disabled = false;
                    forwardBtn.disabled = false;
                    speed90Btn.disabled = false;
                    speed95Btn.disabled = false;
                    speed100Btn.disabled = false;
                });

                // Play/Pause button
                playBtn.addEventListener('click', () => {
                    if (audioElement.paused) {
                        audioElement.play();
                        playBtn.classList.add('playing');
                    } else {
                        audioElement.pause();
                        playBtn.classList.remove('playing');
                    }
                });

                // Restart button
                restartBtn.addEventListener('click', () => {
                    audioElement.currentTime = 0;
                    if (audioElement.paused) {
                        audioElement.play();
                        playBtn.classList.add('playing');
                    }
                });

                // Back 10 seconds button
                backBtn.addEventListener('click', () => {
                    audioElement.currentTime = Math.max(0, audioElement.currentTime - 10);
                });

                // Forward 10 seconds button
                forwardBtn.addEventListener('click', () => {
                    audioElement.currentTime = Math.min(audioElement.duration, audioElement.currentTime + 10);
                });

                // Speed control buttons
                const setSpeed = (speed, activeBtn) => {
                    audioElement.playbackRate = speed;
                    speed90Btn.classList.remove('active');
                    speed95Btn.classList.remove('active');
                    speed100Btn.classList.remove('active');
                    activeBtn.classList.add('active');
                    console.log('Playback speed set to:', speed);
                };

                speed90Btn.addEventListener('click', () => setSpeed(0.9, speed90Btn));
                speed95Btn.addEventListener('click', () => setSpeed(0.95, speed95Btn));
                speed100Btn.addEventListener('click', () => setSpeed(1.0, speed100Btn));

                // Update progress bar
                audioElement.addEventListener('timeupdate', () => {
                    const progress = (audioElement.currentTime / audioElement.duration) * 100;
                    progressBar.style.width = progress + '%';

                    // Update time display
                    const currentMin = Math.floor(audioElement.currentTime / 60);
                    const currentSec = Math.floor(audioElement.currentTime % 60).toString().padStart(2, '0');
                    const durationMin = Math.floor(audioElement.duration / 60);
                    const durationSec = Math.floor(audioElement.duration % 60).toString().padStart(2, '0');
                    timeDisplay.textContent = `${currentMin}:${currentSec} / ${durationMin}:${durationSec}`;
                });

                // Seek by clicking progress bar
                progressContainer.addEventListener('click', (e) => {
                    const rect = progressContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = rect.width;
                    const percentage = clickX / width;
                    audioElement.currentTime = percentage * audioElement.duration;
                });

                // Reset play button when audio ends
                audioElement.addEventListener('ended', () => {
                    playBtn.classList.remove('playing');
                    progressBar.style.width = '0%';
                });

                audioListenersInitialized = true;
                console.log('Audio event listeners initialized');
            },

            async loadAudio(audioPath) {
                const playBtn = document.getElementById('playBtn');
                const restartBtn = document.getElementById('restartBtn');
                const backBtn = document.getElementById('backBtn');
                const forwardBtn = document.getElementById('forwardBtn');
                const speed90Btn = document.getElementById('speed90Btn');
                const speed95Btn = document.getElementById('speed95Btn');
                const speed100Btn = document.getElementById('speed100Btn');
                const progressBar = document.getElementById('progressBar');
                const timeDisplay = document.getElementById('timeDisplay');

                // Initialize audio element if not already done
                if (!audioElement) {
                    audioElement = document.getElementById('danceAudio');
                    this.setupAudioEventListeners();
                }

                // Clean up old audio state
                console.log('Cleaning up old audio state before loading new audio');
                audioElement.pause();
                audioElement.currentTime = 0;
                audioElement.playbackRate = 1.0; // Reset playback speed
                playBtn.classList.remove('playing');
                playBtn.disabled = true;
                restartBtn.disabled = true;
                backBtn.disabled = true;
                forwardBtn.disabled = true;
                speed90Btn.disabled = true;
                speed95Btn.disabled = true;
                speed100Btn.disabled = true;

                // Reset speed button visual state
                speed90Btn.classList.remove('active');
                speed95Btn.classList.remove('active');
                speed100Btn.classList.add('active');

                progressBar.style.width = '0%';
                timeDisplay.textContent = '0:00 / 0:00';

                // Revoke old blob URL to free memory
                if (currentBlobURL) {
                    console.log('Revoking old blob URL:', currentBlobURL);
                    URL.revokeObjectURL(currentBlobURL);
                    currentBlobURL = null;
                }

                try {
                    // Extract filename from path (e.g., "data/dance_audio_tracks/fjaskern.mp3" -> "fjaskern.mp3")
                    const filename = audioPath.split('/').pop();
                    console.log('Attempting to load audio file:', filename);

                    // Load audio file from parent app's folder handle
                    const folderHandle = window.parent.app.fileManager.folderHandle;
                    if (!folderHandle) {
                        throw new Error('No folder handle available - data folder not loaded');
                    }

                    console.log('Looking for dance_audio_tracks folder...');
                    // Navigate to dance_audio_tracks folder
                    const audioFolderHandle = await folderHandle.getDirectoryHandle('dance_audio_tracks');
                    console.log('Found dance_audio_tracks folder, looking for file:', filename);

                    const fileHandle = await audioFolderHandle.getFileHandle(filename);
                    const file = await fileHandle.getFile();

                    // Create blob URL from file
                    currentBlobURL = URL.createObjectURL(file);
                    audioElement.src = currentBlobURL;
                    audioElement.load(); // Force reload of the new source

                    console.log(`Successfully loaded audio file: ${filename} as blob URL`);
                } catch (error) {
                    console.error('Failed to load audio file:', audioPath);
                    console.error('Error details:', error.name, error.message);

                    if (error.name === 'NotFoundError') {
                        timeDisplay.textContent = 'Create dance_audio_tracks folder in data/';
                        this.showError('Audio folder not found. Create a "dance_audio_tracks" folder inside your data folder and place MP3 files there.');
                    } else {
                        timeDisplay.textContent = 'Audio unavailable';
                    }
                    return;
                }
            },

            showError(message) {
                document.getElementById('danceTitle').textContent = 'Error';
                document.getElementById('danceChartContainer').innerHTML =
                    `<div class="error-message">${message}</div>`;
            },

            getResponse() {
                // No response needed for view-only module
                return "";
            },

            isComplete() {
                // Always complete (view-only, no interaction required)
                return true;
            },

            buildBeatBoxList() {
                // Build a flat list of all beat boxes in order, respecting repeats
                beatBoxes = [];

                if (!currentDance || !currentDance.sections) {
                    console.warn('No dance loaded');
                    return;
                }

                currentDance.sections.forEach(section => {
                    const sectionBoxes = [];

                    // Find all beat boxes in this section
                    const sectionElements = document.querySelectorAll('.section');
                    sectionElements.forEach(sectionEl => {
                        const letterEl = sectionEl.querySelector('.section-letter');
                        if (letterEl && letterEl.textContent === section.letter) {
                            const boxes = sectionEl.querySelectorAll('.beat-box');
                            boxes.forEach(box => {
                                if (box.textContent.trim()) { // Only non-empty boxes
                                    sectionBoxes.push(box);
                                }
                            });
                        }
                    });

                    // Add section boxes once
                    beatBoxes.push(...sectionBoxes);

                    // If section repeats, add again
                    if (section.repeats) {
                        beatBoxes.push(...sectionBoxes);
                    }
                });

                console.log(`Built beat box list: ${beatBoxes.length} beats`);
            },

            startMetronome(bpm) {
                console.log(`Starting metronome at ${bpm} BPM`);

                // Stop any existing metronome
                this.stopMetronome();

                // Build the beat list
                this.buildBeatBoxList();

                if (beatBoxes.length === 0) {
                    console.warn('No beats to highlight - load a dance first');
                    return;
                }

                // Update button states
                document.getElementById('metro65Btn').classList.remove('active');
                document.getElementById('metro85Btn').classList.remove('active');
                document.getElementById('metro95Btn').classList.remove('active');
                document.getElementById('metroStopBtn').classList.remove('active');

                if (bpm === 65) document.getElementById('metro65Btn').classList.add('active');
                if (bpm === 85) document.getElementById('metro85Btn').classList.add('active');
                if (bpm === 95) document.getElementById('metro95Btn').classList.add('active');

                metronomeBPM = bpm;
                const beatDuration = (60 / bpm) * 1000; // ms per beat

                // Start countdown
                countdownBeats = 4;
                currentBeatIndex = -1;

                console.log(`Countdown starting: 4 beats at ${beatDuration.toFixed(0)}ms per beat`);

                metronomeInterval = setInterval(() => {
                    if (countdownBeats > 0) {
                        // Countdown phase
                        playCountdownClick();
                        console.log(`Countdown: ${countdownBeats}`);
                        countdownBeats--;
                    } else {
                        // Beat highlighting phase
                        this.nextBeat();
                    }
                }, beatDuration);
            },

            nextBeat() {
                // Remove highlight from previous beat
                if (currentBeatIndex >= 0 && currentBeatIndex < beatBoxes.length) {
                    beatBoxes[currentBeatIndex].classList.remove('highlighted');
                }

                // Advance to next beat
                currentBeatIndex++;

                // Loop back to start if at end
                if (currentBeatIndex >= beatBoxes.length) {
                    currentBeatIndex = 0;
                    console.log('Looping back to start');
                }

                // Play metronome click (downbeat on first beat)
                const isDownbeat = (currentBeatIndex === 0);
                playMetronomeClick(isDownbeat);

                // Highlight current beat
                beatBoxes[currentBeatIndex].classList.add('highlighted');

                // Scroll to keep current beat visible
                beatBoxes[currentBeatIndex].scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                console.log(`Beat ${currentBeatIndex + 1}/${beatBoxes.length}: "${beatBoxes[currentBeatIndex].textContent}"`);
            },

            stopMetronome() {
                console.log('Stopping metronome');

                // Clear interval
                if (metronomeInterval) {
                    clearInterval(metronomeInterval);
                    metronomeInterval = null;
                }

                // Remove all highlights
                document.querySelectorAll('.beat-box.highlighted').forEach(box => {
                    box.classList.remove('highlighted');
                });

                // Reset state
                currentBeatIndex = -1;
                countdownBeats = 0;
                metronomeBPM = null;

                // Update button states
                document.getElementById('metro65Btn').classList.remove('active');
                document.getElementById('metro85Btn').classList.remove('active');
                document.getElementById('metro95Btn').classList.remove('active');
                document.getElementById('metroStopBtn').classList.add('active');

                // Remove stop button active state after a moment
                setTimeout(() => {
                    document.getElementById('metroStopBtn').classList.remove('active');
                }, 200);
            },

            reset() {
                // Stop metronome
                this.stopMetronome();

                // Stop audio playback and clean up
                if (audioElement) {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                    const playBtn = document.getElementById('playBtn');
                    playBtn.classList.remove('playing');
                }

                // Revoke blob URL to free memory
                if (currentBlobURL) {
                    console.log('Revoking blob URL on reset');
                    URL.revokeObjectURL(currentBlobURL);
                    currentBlobURL = null;
                }
            }
        };

        // Listen for messages from parent app
        window.addEventListener('message', function (event) {
            if (event.data && event.data.type === 'taskmodule:init') {
                window.TaskModule.init(event.data.context);
            }
        });

        // Notify parent that module is ready
        window.addEventListener('load', function () {
            console.log('Dance viewer module loaded');
        });
    </script>
</body>
</html>
