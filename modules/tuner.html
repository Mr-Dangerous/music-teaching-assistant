<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pitch Tuner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: white;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Control bar at top */
    .control-bar {
      display: flex;
      gap: 10px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.3);
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }

    .control-bar select,
    .control-bar button {
      height: 50px;
      font-size: 18px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
    }

    .control-bar select {
      padding: 0 15px;
      background: white;
      color: #1a1a2e;
      min-width: 120px;
    }

    .control-bar button {
      padding: 0 25px;
      color: white;
      transition: all 0.3s;
      min-width: 140px;
    }

    .btn-play-3s {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .btn-play-continuous {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .btn-play-continuous.active {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      box-shadow: 0 0 20px rgba(250, 112, 154, 0.6);
    }

    .btn-mic {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .btn-mic.active {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      box-shadow: 0 0 20px rgba(67, 233, 123, 0.6);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .control-bar button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .control-bar button:active {
      transform: translateY(0);
    }

    /* Main visualization area */
    .visualization {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Note wheel container */
    .note-wheel-container {
      position: relative;
      z-index: 10;
      width: 400px;
      height: 400px;
    }

    #note-wheel-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Center display */
    .center-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 11;
      text-align: center;
      background: rgba(0, 0, 0, 0.6);
      padding: 30px 50px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }

    .note-name {
      font-size: 90px;
      font-weight: bold;
      margin: 0;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
    }

    .frequency {
      font-size: 28px;
      color: #a0a0a0;
      margin: 10px 0;
    }

    .tuning-status {
      font-size: 24px;
      font-weight: bold;
      margin-top: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .tuning-status.flat {
      color: #ff6b6b;
    }

    .tuning-status.in-tune {
      color: #51cf66;
      text-shadow: 0 0 20px rgba(81, 207, 102, 0.8);
    }

    .tuning-status.sharp {
      color: #4dabf7;
    }

    .instruction {
      font-size: 18px;
      color: #888;
      margin-top: 15px;
    }

    /* Cents indicator */
    .cents-indicator {
      margin-top: 12px;
      font-size: 22px;
      color: #ccc;
    }

    /* Signal strength meter */
    .signal-meter {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
      min-width: 200px;
    }

    .signal-meter-label {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 8px;
    }

    .signal-bar-container {
      width: 100%;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      overflow: hidden;
    }

    .signal-bar {
      height: 100%;
      background: linear-gradient(90deg, #51cf66 0%, #ffd43b 70%, #ff6b6b 100%);
      width: 0%;
      transition: width 0.1s ease;
    }
  </style>
</head>
<body>
  <div class="control-bar">
    <select id="pitch-select">
      <!-- Generated by JavaScript -->
    </select>
    <select id="tolerance-select">
      <option value="20">Beginner (±20¢)</option>
      <option value="10" selected>Standard (±10¢)</option>
      <option value="5">Professional (±5¢)</option>
    </select>
    <button class="btn-play-3s" id="btn-play-3s">Play 3 sec</button>
    <button class="btn-play-continuous" id="btn-play-continuous">Play Continuous</button>
    <button class="btn-mic" id="btn-mic">Enable Mic</button>
  </div>

  <div class="visualization">
    <canvas id="laser-canvas"></canvas>
    <div class="signal-meter" id="signal-meter" style="display: none;">
      <div class="signal-meter-label">Signal Strength</div>
      <div class="signal-bar-container">
        <div class="signal-bar" id="signal-bar"></div>
      </div>
    </div>
    <div class="note-wheel-container">
      <canvas id="note-wheel-canvas" width="400" height="400"></canvas>
      <div class="center-display" id="center-display">
        <div class="note-name" id="note-name">--</div>
        <div class="frequency" id="frequency">-- Hz</div>
        <div class="tuning-status" id="tuning-status"></div>
        <div class="cents-indicator" id="cents-indicator"></div>
        <div class="instruction">Select a pitch and enable the microphone</div>
      </div>
    </div>
  </div>

  <script>
    // ========== PITCH DATA ==========
    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Generate pitch list from A3 (220 Hz) to A6 (1760 Hz)
    function generatePitches() {
      const pitches = [];
      // Start from C3 to make the range easier (MIDI 48 = C3)
      for (let midi = 57; midi <= 93; midi++) { // A3 (MIDI 57) to A6 (MIDI 93)
        const freq = 440 * Math.pow(2, (midi - 69) / 12);
        const octave = Math.floor((midi + 3) / 12);
        const noteName = NOTES[midi % 12];
        pitches.push({ name: `${noteName}${octave}`, freq, midi });
      }
      return pitches;
    }

    const PITCHES = generatePitches();

    // ========== STATE ==========
    let audioContext = null;
    let oscillator = null;
    let gainNode = null;
    let micStream = null;
    let analyser = null;
    let isPlayingContinuous = false;
    let isMicActive = false;
    let selectedPitch = PITCHES.find(p => p.name === 'A4'); // Default A4 (440 Hz)
    let detectionInterval = null;
    let tolerance = 10; // cents
    let wheelRotation = 0; // Current rotation angle
    let targetWheelRotation = 0; // Target rotation angle
    let validNoteRange = []; // Notes within ±2 semitones of target

    // ========== DOM ELEMENTS ==========
    const pitchSelect = document.getElementById('pitch-select');
    const toleranceSelect = document.getElementById('tolerance-select');
    const btnPlay3s = document.getElementById('btn-play-3s');
    const btnPlayContinuous = document.getElementById('btn-play-continuous');
    const btnMic = document.getElementById('btn-mic');
    const canvas = document.getElementById('laser-canvas');
    const ctx = canvas.getContext('2d');
    const wheelCanvas = document.getElementById('note-wheel-canvas');
    const wheelCtx = wheelCanvas.getContext('2d');
    const noteNameEl = document.getElementById('note-name');
    const frequencyEl = document.getElementById('frequency');
    const tuningStatusEl = document.getElementById('tuning-status');
    const centsIndicatorEl = document.getElementById('cents-indicator');
    const signalMeter = document.getElementById('signal-meter');
    const signalBar = document.getElementById('signal-bar');

    // ========== INITIALIZE ==========
    function init() {
      // Ensure selectedPitch is set
      if (!selectedPitch) {
        selectedPitch = PITCHES.find(p => p.name === 'A4') || PITCHES[0];
      }

      // Populate pitch dropdown
      PITCHES.forEach(pitch => {
        const option = document.createElement('option');
        option.value = pitch.name;
        option.textContent = pitch.name;
        if (pitch.name === 'A4') option.selected = true;
        pitchSelect.appendChild(option);
      });

      // Setup canvas
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Event listeners
      pitchSelect.addEventListener('change', handlePitchChange);
      toleranceSelect.addEventListener('change', handleToleranceChange);
      btnPlay3s.addEventListener('click', playFor3Seconds);
      btnPlayContinuous.addEventListener('click', toggleContinuousPlay);
      btnMic.addEventListener('click', toggleMicrophone);

      // Initialize valid note range
      updateValidNoteRange();

      // Start animation loops
      animateLasers();
      animateWheel();

      console.log('Tuner initialized with target pitch:', selectedPitch.name);
    }

    // ========== NOTE WHEEL FUNCTIONS ==========
    function updateValidNoteRange() {
      // Get notes within ±2 semitones of selected pitch
      validNoteRange = [];

      if (!selectedPitch) {
        console.error('No pitch selected');
        return;
      }

      const targetMidi = selectedPitch.midi;

      for (let offset = -2; offset <= 2; offset++) {
        const midi = targetMidi + offset;
        const pitch = PITCHES.find(p => p.midi === midi);
        if (pitch) {
          validNoteRange.push(pitch);
        }
      }
      console.log('Valid note range:', validNoteRange.map(p => p.name).join(', '));
    }

    function getNoteIndexInRange(noteName) {
      return validNoteRange.findIndex(p => p.name === noteName);
    }

    function animateWheel() {
      requestAnimationFrame(animateWheel);

      // Smooth rotation interpolation
      const rotationDiff = targetWheelRotation - wheelRotation;
      wheelRotation += rotationDiff * 0.15; // Smooth easing

      drawNoteWheel();
    }

    function drawNoteWheel() {
      const width = wheelCanvas.width;
      const height = wheelCanvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = 150;

      // Clear canvas
      wheelCtx.clearRect(0, 0, width, height);

      if (validNoteRange.length === 0) return;

      // Draw circle background
      wheelCtx.beginPath();
      wheelCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      wheelCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      wheelCtx.lineWidth = 3;
      wheelCtx.stroke();

      // Draw notes around the wheel
      const numNotes = validNoteRange.length;
      const angleStep = (Math.PI * 2) / numNotes;

      validNoteRange.forEach((pitch, index) => {
        const angle = wheelRotation + index * angleStep - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        // Calculate opacity based on position (top = most visible)
        const normalizedAngle = ((angle + Math.PI / 2) % (Math.PI * 2));
        const distanceFromTop = Math.abs(normalizedAngle - Math.PI);
        const opacity = 1 - (distanceFromTop / Math.PI) * 0.7;

        // Calculate size based on position (top = largest)
        const scale = 1 - (distanceFromTop / Math.PI) * 0.5;
        const fontSize = 36 * scale;

        // Determine color based on position relative to target
        let color;
        if (pitch.name === selectedPitch.name) {
          color = `rgba(81, 207, 102, ${opacity})`; // Green for target
        } else if (pitch.midi < selectedPitch.midi) {
          color = `rgba(255, 107, 107, ${opacity})`; // Red for flat
        } else {
          color = `rgba(77, 171, 247, ${opacity})`; // Blue for sharp
        }

        // Draw note name
        wheelCtx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
        wheelCtx.fillStyle = color;
        wheelCtx.textAlign = 'center';
        wheelCtx.textBaseline = 'middle';
        wheelCtx.fillText(pitch.name, x, y);

        // Add glow for top note
        if (distanceFromTop < 0.3) {
          wheelCtx.shadowBlur = 20;
          wheelCtx.shadowColor = color;
          wheelCtx.fillText(pitch.name, x, y);
          wheelCtx.shadowBlur = 0;
        }
      });

      // Draw pointer at top
      wheelCtx.beginPath();
      wheelCtx.moveTo(centerX - 15, centerY - radius - 20);
      wheelCtx.lineTo(centerX + 15, centerY - radius - 20);
      wheelCtx.lineTo(centerX, centerY - radius - 5);
      wheelCtx.closePath();
      wheelCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      wheelCtx.fill();
    }

    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }

    // ========== AUDIO CONTEXT ==========
    function getAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // ========== EVENT HANDLERS ==========
    function handlePitchChange(e) {
      selectedPitch = PITCHES.find(p => p.name === e.target.value);
      updateValidNoteRange();
      wheelRotation = 0;
      targetWheelRotation = 0;
    }

    function handleToleranceChange(e) {
      tolerance = parseInt(e.target.value);
    }

    function playFor3Seconds() {
      playTone(selectedPitch.freq, 3000);
    }

    function toggleContinuousPlay() {
      if (isPlayingContinuous) {
        stopContinuousPlay();
      } else {
        startContinuousPlay();
      }
    }

    async function toggleMicrophone() {
      if (isMicActive) {
        stopMicrophone();
      } else {
        await startMicrophone();
      }
    }

    // ========== TONE GENERATION ==========
    function playTone(frequency, duration = null) {
      const ctx = getAudioContext();

      // Stop any existing oscillator
      if (oscillator) {
        oscillator.stop();
        oscillator = null;
      }

      oscillator = ctx.createOscillator();
      gainNode = ctx.createGain();

      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(frequency, ctx.currentTime);

      gainNode.gain.setValueAtTime(0.3, ctx.currentTime);

      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);

      oscillator.start();

      if (duration) {
        setTimeout(() => {
          if (oscillator) {
            oscillator.stop();
            oscillator = null;
          }
        }, duration);
      }
    }

    function startContinuousPlay() {
      playTone(selectedPitch.freq);
      isPlayingContinuous = true;
      btnPlayContinuous.classList.add('active');
      btnPlayContinuous.textContent = 'Stop Playing';
    }

    function stopContinuousPlay() {
      if (oscillator) {
        oscillator.stop();
        oscillator = null;
      }
      isPlayingContinuous = false;
      btnPlayContinuous.classList.remove('active');
      btnPlayContinuous.textContent = 'Play Continuous';
    }

    // ========== MICROPHONE & PITCH DETECTION ==========
    async function startMicrophone() {
      try {
        const ctx = getAudioContext();
        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            autoGainControl: false,
            noiseSuppression: false
          }
        });

        const source = ctx.createMediaStreamSource(micStream);
        analyser = ctx.createAnalyser();
        analyser.fftSize = 8192; // Increased for better low-frequency detection
        analyser.smoothingTimeConstant = 0.8;
        source.connect(analyser);

        isMicActive = true;
        btnMic.classList.add('active');
        btnMic.textContent = 'Mic Active';
        signalMeter.style.display = 'block';

        console.log('Microphone started successfully');

        // Start pitch detection loop
        detectionInterval = setInterval(detectPitch, 50); // Faster updates (50ms = 20fps)
      } catch (err) {
        alert('Microphone access denied. Please allow microphone access and try again.');
        console.error('Microphone error:', err);
      }
    }

    function stopMicrophone() {
      if (micStream) {
        micStream.getTracks().forEach(track => track.stop());
        micStream = null;
      }
      if (detectionInterval) {
        clearInterval(detectionInterval);
        detectionInterval = null;
      }
      isMicActive = false;
      btnMic.classList.remove('active');
      btnMic.textContent = 'Enable Mic';
      signalMeter.style.display = 'none';

      // Reset display
      noteNameEl.textContent = '--';
      frequencyEl.textContent = '-- Hz';
      tuningStatusEl.textContent = '';
      centsIndicatorEl.textContent = '';
      currentCents = 0;
    }

    // ========== PITCH DETECTION (Autocorrelation) ==========
    let currentCents = 0;
    let detectionCount = 0;
    let lastRMS = 0;
    let laserRotation = 0; // Rotation angle for lasers
    let isInTune = false; // Track if currently in tune

    function detectPitch() {
      if (!analyser) return;

      const bufferLength = analyser.fftSize;
      const buffer = new Float32Array(bufferLength);
      analyser.getFloatTimeDomainData(buffer);

      // Calculate RMS for signal strength meter
      let rms = 0;
      for (let i = 0; i < buffer.length; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / buffer.length);
      lastRMS = rms;

      // Update signal strength meter
      const signalPercent = Math.min(100, (rms / 0.3) * 100); // Scale to 0-100%
      signalBar.style.width = signalPercent + '%';

      const frequency = autoCorrelate(buffer, audioContext.sampleRate);

      if (frequency > 0) {
        const detectedNote = frequencyToNote(frequency);

        // Filter: Only process notes within valid range (±2 semitones of target)
        const isInRange = validNoteRange.some(p => p.name === detectedNote.name);

        if (!isInRange) {
          // Show out of range message
          noteNameEl.textContent = detectedNote.name;
          frequencyEl.textContent = `${frequency.toFixed(1)} Hz`;
          tuningStatusEl.textContent = 'OUT OF RANGE';
          tuningStatusEl.className = 'tuning-status';
          tuningStatusEl.style.color = '#888';
          centsIndicatorEl.textContent = '';
          isInTune = false;
          return;
        }

        const cents = calculateCents(frequency, selectedPitch.freq);

        noteNameEl.textContent = detectedNote.name;
        frequencyEl.textContent = `${frequency.toFixed(1)} Hz`;
        centsIndicatorEl.textContent = `${cents > 0 ? '+' : ''}${cents.toFixed(0)}¢`;

        // Update tuning status
        if (Math.abs(cents) <= tolerance) {
          tuningStatusEl.textContent = 'IN TUNE';
          tuningStatusEl.className = 'tuning-status in-tune';
          tuningStatusEl.style.color = '';
          isInTune = true;
        } else if (cents < 0) {
          tuningStatusEl.textContent = 'FLAT';
          tuningStatusEl.className = 'tuning-status flat';
          tuningStatusEl.style.color = '';
          isInTune = false;
        } else {
          tuningStatusEl.textContent = 'SHARP';
          tuningStatusEl.className = 'tuning-status sharp';
          tuningStatusEl.style.color = '';
          isInTune = false;
        }

        currentCents = cents;

        // Update wheel rotation to show detected note at top
        const noteIndex = getNoteIndexInRange(detectedNote.name);
        if (noteIndex !== -1) {
          const angleStep = (Math.PI * 2) / validNoteRange.length;
          targetWheelRotation = -noteIndex * angleStep;
        }
      } else {
        // No pitch detected but mic is active - show waiting message
        if (rms < 0.005) {
          noteNameEl.textContent = 'Listening...';
          frequencyEl.textContent = '';
          tuningStatusEl.textContent = '';
          centsIndicatorEl.textContent = '';
        }
        isInTune = false;
      }
    }

    function autoCorrelate(buffer, sampleRate) {
      // Find the first crossing of zero
      let size = buffer.length;
      let maxSamples = Math.floor(size / 2);
      let best_offset = -1;
      let best_correlation = 0;
      let rms = 0;

      // Calculate RMS (root mean square) to detect if there's enough signal
      for (let i = 0; i < size; i++) {
        rms += buffer[i] * buffer[i];
      }
      rms = Math.sqrt(rms / size);

      if (rms < 0.005) return -1; // Lowered threshold for more sensitivity

      // Find the first zero crossing
      let lastCorrelation = 1;
      for (let offset = 1; offset < maxSamples; offset++) {
        let correlation = 0;
        for (let i = 0; i < maxSamples; i++) {
          correlation += Math.abs(buffer[i] - buffer[i + offset]);
        }
        correlation = 1 - (correlation / maxSamples);

        if (correlation > 0.9 && correlation > lastCorrelation) {
          const foundGoodCorrelation = true;
          if (foundGoodCorrelation) {
            if (correlation > best_correlation) {
              best_correlation = correlation;
              best_offset = offset;
            }
          }
        }
        lastCorrelation = correlation;
      }

      if (best_offset === -1) return -1;

      return sampleRate / best_offset;
    }

    function frequencyToNote(frequency) {
      const midi = 69 + 12 * Math.log2(frequency / 440);
      const roundedMidi = Math.round(midi);
      const noteName = NOTES[roundedMidi % 12];
      const octave = Math.floor((roundedMidi + 3) / 12);
      return { name: `${noteName}${octave}`, midi: roundedMidi };
    }

    function calculateCents(detectedFreq, targetFreq) {
      return 1200 * Math.log2(detectedFreq / targetFreq);
    }

    // ========== LASER VISUALIZATION ==========
    function animateLasers() {
      requestAnimationFrame(animateLasers);
      drawLasers();
    }

    function drawLasers() {
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;

      // Clear canvas
      ctx.fillStyle = 'rgba(26, 26, 46, 0.1)';
      ctx.fillRect(0, 0, width, height);

      if (!isMicActive) return;

      // Update laser rotation (only rotate when in tune)
      if (isInTune) {
        laserRotation += 0.02; // Rotate speed
      }

      // Calculate laser spread based on cents
      const maxCents = 50; // Maximum cents for full spread
      const centsNormalized = Math.max(-maxCents, Math.min(maxCents, currentCents));
      const spreadFactor = Math.abs(centsNormalized) / maxCents;

      // Number of lasers
      const numLasers = 12;
      const baseAngle = (Math.PI * 2) / numLasers;

      for (let i = 0; i < numLasers; i++) {
        const angle = i * baseAngle + laserRotation; // Apply rotation

        // Calculate spread (lasers focus when in tune)
        const spread = spreadFactor * 0.3;
        const finalAngle = angle + (Math.random() - 0.5) * spread;

        // Calculate color based on cents
        let color;
        if (Math.abs(currentCents) <= tolerance) {
          // In tune - green
          color = `rgba(81, 207, 102, ${0.6 - spreadFactor * 0.4})`;
        } else if (currentCents < 0) {
          // Flat - red/orange
          const hue = 0 + (i / numLasers) * 30; // Red to orange
          color = `hsla(${hue}, 100%, 60%, ${0.6 - spreadFactor * 0.4})`;
        } else {
          // Sharp - blue/purple/magenta
          const hue = 200 + (i / numLasers) * 100; // Blue to magenta
          color = `hsla(${hue}, 100%, 60%, ${0.6 - spreadFactor * 0.4})`;
        }

        // Draw laser
        const endX = centerX + Math.cos(finalAngle) * Math.max(width, height);
        const endY = centerY + Math.sin(finalAngle) * Math.max(width, height);

        const gradient = ctx.createLinearGradient(centerX, centerY, endX, endY);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

        ctx.beginPath();
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3 + (1 - spreadFactor) * 5; // Thicker when focused
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Add glow
        ctx.beginPath();
        ctx.strokeStyle = color.replace(/[\d.]+\)$/, '0.3)');
        ctx.lineWidth = 8 + (1 - spreadFactor) * 10;
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }

      // Draw center glow
      if (Math.abs(currentCents) <= tolerance) {
        const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
        glowGradient.addColorStop(0, 'rgba(81, 207, 102, 0.4)');
        glowGradient.addColorStop(1, 'rgba(81, 207, 102, 0)');
        ctx.fillStyle = glowGradient;
        ctx.fillRect(0, 0, width, height);
      }
    }

    // ========== TASKMODULE INTERFACE ==========
    window.TaskModule = {
      init: function(context) {
        console.log('Tuner module initialized:', context);
        // This is a practice tool - no need to restore state
      },

      getResponse: function() {
        // Return a simple response indicating the tool was used
        return 'tuner-practice-tool';
      },

      isComplete: function() {
        // Always complete since it's a practice tool
        return true;
      },

      reset: function() {
        // Stop any active audio/microphone
        stopContinuousPlay();
        stopMicrophone();
      }
    };

    // Listen for init message from parent
    window.addEventListener('message', (event) => {
      if (event.data.type === 'taskmodule:init') {
        window.TaskModule.init(event.data.context);
      }
    });

    // ========== START ==========
    init();
  </script>
</body>
</html>
