<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>So La Mi Re Do Trainer</title>
    <style>
        :root {
            /* Resolution scaling - inherits from parent or defaults to 1 */
            --module-scale: 1;
        }

        /* Detect 4K mode from parent */
        body.resolution-4k,
        :root.resolution-4k {
            --module-scale: 2;
            transform: scale(2);
            transform-origin: top left;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            padding: calc(10px * var(--module-scale));
            overflow: hidden;
        }

        .container {
            width: 100%;
            max-width: calc(900px * var(--module-scale));
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: flex-start;
            gap: calc(10px * var(--module-scale));
        }

        .refresh-btn {
            align-self: flex-start;
            font-size: calc(18px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #3498db;
            border: none;
            padding: calc(12px * var(--module-scale)) calc(24px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            margin-bottom: 0;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .refresh-btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        #staffCanvas {
            display: block;
            border: 3px solid #3498db;
            border-radius: 5px;
            background-color: white;
            max-width: 100%;
            flex-shrink: 0;
        }

        .label-container {
            display: flex;
            gap: calc(15px * var(--module-scale));
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 0;
            flex-shrink: 0;
        }

        .toggle-labels-btn {
            font-size: calc(16px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #9b59b6;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            margin-top: 0;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .toggle-labels-btn:hover {
            background-color: #8e44ad;
        }

        .draggable-label {
            font-size: calc(28px * var(--module-scale));
            font-weight: bold;
            color: #2c3e50;
            padding: calc(12px * var(--module-scale)) calc(32px * var(--module-scale));
            background-color: #e74c3c;
            border: calc(3px * var(--module-scale)) solid #c0392b;
            border-radius: calc(8px * var(--module-scale));
            cursor: grab;
            user-select: none;
            touch-action: none;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .draggable-label:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        .draggable-label.dragging {
            opacity: 0.7;
            position: fixed;
            z-index: 1000;
            pointer-events: none;
            border: none;
            border-bottom: calc(3px * var(--module-scale)) solid #2c3e50;
        }

        .draggable-label.placed {
            border: none;
            background-color: transparent;
            box-shadow: none;
            padding: 0;
            font-size: calc(28px * var(--module-scale));
            color: white;
            text-shadow: 0 0 calc(3px * var(--module-scale)) rgba(0, 0, 0, 0.5);
        }

        .first-note-btn {
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #9b59b6;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .first-note-btn:hover {
            background-color: #8e44ad;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .note-count-btn {
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #34495e;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .note-count-btn:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .custom-pattern-btn {
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #c0392b;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .custom-pattern-btn:hover {
            background-color: #a93226;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .color-toggle-btn {
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #16a085;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .color-toggle-btn:hover {
            background-color: #138d75;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .undo-btn {
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            background-color: #e67e22;
            border: none;
            padding: calc(10px * var(--module-scale)) calc(20px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .undo-btn:hover {
            background-color: #d35400;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .undo-btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: calc(30px * var(--module-scale));
            border-radius: calc(10px * var(--module-scale));
            max-width: calc(400px * var(--module-scale));
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 calc(4px * var(--module-scale)) calc(20px * var(--module-scale)) rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: calc(20px * var(--module-scale));
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: calc(15px * var(--module-scale));
            text-align: center;
        }

        .modal-description {
            font-size: calc(12px * var(--module-scale));
            color: #7f8c8d;
            margin-bottom: calc(15px * var(--module-scale));
            text-align: center;
        }

        .radio-list {
            margin: calc(20px * var(--module-scale)) 0;
        }

        .radio-item {
            display: flex;
            align-items: center;
            padding: calc(5px * var(--module-scale)) 0;
            font-size: calc(14px * var(--module-scale));
        }

        .radio-item input {
            margin-right: calc(10px * var(--module-scale));
            width: calc(18px * var(--module-scale));
            height: calc(18px * var(--module-scale));
            cursor: pointer;
        }

        .radio-item label {
            cursor: pointer;
        }

        .modal-buttons {
            display: flex;
            gap: calc(15px * var(--module-scale));
            justify-content: center;
            margin-top: calc(20px * var(--module-scale));
        }

        .btn-save {
            background-color: #27ae60;
            padding: calc(12px * var(--module-scale)) calc(35px * var(--module-scale));
            font-size: calc(14px * var(--module-scale));
            font-weight: bold;
            color: white;
            border: none;
            border-radius: calc(5px * var(--module-scale));
            cursor: pointer;
            box-shadow: 0 calc(2px * var(--module-scale)) calc(5px * var(--module-scale)) rgba(0, 0, 0, 0.2);
        }

        .btn-save:hover {
            background-color: #229954;
        }

        .btn-cancel {
            background-color: #95a5a6;
            padding: 12px 25px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .btn-cancel:hover {
            background-color: #7f8c8d;
        }

        input[type="text"].pattern-input {
            width: 100%;
            padding: calc(10px * var(--module-scale));
            font-size: calc(16px * var(--module-scale));
            font-family: monospace;
            border: calc(2px * var(--module-scale)) solid #bdc3c7;
            border-radius: calc(5px * var(--module-scale));
            margin: calc(15px * var(--module-scale)) 0;
            text-align: center;
            text-transform: lowercase;
        }

        input[type="text"].pattern-input:focus {
            outline: none;
            border-color: #2ecc71;
        }

        .syntax-help {
            background-color: #ecf0f1;
            padding: calc(10px * var(--module-scale));
            border-radius: calc(5px * var(--module-scale));
            margin: calc(10px * var(--module-scale)) 0 calc(15px * var(--module-scale));
            font-size: calc(12px * var(--module-scale));
            color: #2c3e50;
        }

        .syntax-help p {
            margin: calc(5px * var(--module-scale)) 0;
        }

        .syntax-help code {
            background-color: #34495e;
            color: white;
            padding: calc(2px * var(--module-scale)) calc(6px * var(--module-scale));
            border-radius: calc(3px * var(--module-scale));
            font-family: monospace;
        }

        /* Completion indicator */
        .completion-indicator {
            position: absolute;
            top: calc(10px * var(--module-scale));
            right: calc(10px * var(--module-scale));
            width: calc(50px * var(--module-scale));
            height: calc(50px * var(--module-scale));
            background-color: #27ae60;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: calc(30px * var(--module-scale));
            color: white;
            box-shadow: 0 calc(4px * var(--module-scale)) calc(8px * var(--module-scale)) rgba(0, 0, 0, 0.3);
            z-index: 100;
            animation: popIn 0.3s ease;
        }

        .completion-indicator.show {
            display: flex;
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container" style="position: relative;">
        <!-- Completion Indicator -->
        <div id="completionIndicator" class="completion-indicator">âœ“</div>

        <div style="display: flex; gap: 10px; align-items: center; width: 100%; justify-content: center;">
            <button class="refresh-btn" onclick="refreshPattern()">ðŸ”„ New Pattern</button>
            <button class="first-note-btn" onclick="openFirstNoteSelection()">First Note</button>
            <button class="note-count-btn" id="noteCountBtn" onclick="toggleNoteCount()">3 Notes</button>
            <button class="custom-pattern-btn" onclick="openCustomPattern()">Custom Pattern</button>
            <button class="color-toggle-btn" id="colorToggleBtn" onclick="toggleColors()">Colors On</button>
            <button class="undo-btn" id="undoBtn" onclick="undoLastPlacement()" disabled>Undo</button>
        </div>

        <canvas id="staffCanvas" width="900" height="250"></canvas>

        <div class="label-container" id="labelContainer">
            <div class="draggable-label" data-note="so">So</div>
            <div class="draggable-label" data-note="la">La</div>
            <div class="draggable-label" data-note="mi">Mi</div>
            <div class="draggable-label" data-note="re">Re</div>
            <div class="draggable-label" data-note="do">Do</div>
        </div>

        <button class="toggle-labels-btn" onclick="toggleStaffLabels()">Toggle Labels</button>
    </div>

    <!-- First Note Selection Modal -->
    <div id="firstNoteModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Select First Note</div>
            <div class="modal-description">Choose which note should always be first in the pattern.<br>Select 'None' for
                random patterns.</div>
            <div class="radio-list" id="firstNoteRadios"></div>
            <div class="modal-buttons">
                <button class="btn-save" onclick="saveFirstNote()">Save</button>
                <button class="btn-cancel" onclick="closeModal('firstNoteModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Custom Pattern Modal -->
    <div id="customPatternModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Enter Custom Pattern</div>
            <div class="modal-description">Type your solfege pattern using the shorthand notation below:</div>

            <div class="syntax-help">
                <strong>Syntax:</strong><br>
                <code>s</code>=so, <code>l</code>=la, <code>m</code>=mi, <code>r</code>=re, <code>d</code>=do<br><br>
                <strong>Example:</strong> <code>slmrd</code> = so, la, mi, re, do
            </div>

            <input type="text" id="customPatternInput" class="pattern-input" placeholder="e.g., slmrd or dsmd"
                maxlength="12">

            <div class="modal-buttons">
                <button class="btn-save" onclick="applyCustomPattern()">Apply</button>
                <button class="btn-cancel" onclick="closeModal('customPatternModal')">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Detect and apply resolution from parent frame
        function detectParentResolution() {
            try {
                // Check if loaded in iframe and parent has resolution class
                if (window.parent && window.parent !== window) {
                    const parentBody = window.parent.document.body;
                    if (parentBody.classList.contains('resolution-4k')) {
                        document.body.classList.add('resolution-4k');
                    }
                }
            } catch (e) {
                // Parent might be cross-origin, that's okay
                console.log('Cannot access parent resolution, using default');
            }
        }

        // Apply resolution on load
        detectParentResolution();

        // TaskModule interface for integration with main app
        window.TaskModule = {
            context: null,

            init(context, savedSettings) {
                this.context = context;
                console.log('So La Mi Re Do Trainer initialized with context:', context);

                // Restore saved settings if provided (and not in practice mode)
                if (savedSettings && context.studentId !== 'practice') {
                    if (savedSettings.firstNote !== undefined) {
                        firstNote = savedSettings.firstNote;
                    }
                    if (savedSettings.numberOfNotes !== undefined) {
                        numberOfNotes = savedSettings.numberOfNotes;
                    }
                    if (savedSettings.customPattern !== undefined) {
                        customPattern = savedSettings.customPattern;
                        // If there's a custom pattern, apply it
                        if (customPattern) {
                            const parsed = parseCustomPattern(customPattern);
                            if (parsed) {
                                currentPattern = parsed;
                                numberOfNotes = parsed.length;
                            }
                        }
                    }
                    console.log('Restored settings:', savedSettings);
                }

                // Now initialize the UI with restored settings
                init();

                // Check if there's an existing response to restore
                if (context.existingResponse) {
                    try {
                        const saved = JSON.parse(context.existingResponse);
                        if (saved.pattern) {
                            // Restore the pattern
                            restorePattern(saved.pattern, saved.placements);
                        }
                    } catch (e) {
                        console.log('No valid existing response to restore');
                    }
                }
            },

            getResponse() {
                return getCurrentResponse();
            },

            isComplete() {
                return checkIfComplete();
            },

            reset() {
                resetModule();
            }
        };

        // Handle messages from parent frame
        function handleMessage(event) {
            // Ensure the message is from a trusted origin if possible
            // For this example, we'll trust all messages, but in production,
            // you might want to check event.origin
            if (event.data && event.data.type === 'taskmodule:save-settings') {
                saveSettings();
            }
        }

        // Save current settings to parent app
        function saveSettings() {
            const settings = {
                firstNote: firstNote,
                numberOfNotes: numberOfNotes,
                customPattern: customPattern
            };

            // Get module path from window location
            const modulePath = window.location.pathname.split('/').pop();

            window.parent.postMessage({
                type: 'taskmodule:settings',
                modulePath: modulePath,
                settings: settings
            }, '*');

            console.log('Saved settings to parent:', settings);
        }

        // Configuration
        const noteColors = {
            'so': '#27ae60',  // Green
            'la': '#9b59b6',  // Purple
            'mi': '#f1c40f',  // Yellow
            're': '#e67e22',  // Orange
            'do': '#e74c3c'   // Red
        };

        // State
        let currentPattern = [];
        let notePositions = [];
        let labelPlacements = {}; // Maps note position index to label note name
        let draggedLabel = null;
        let dragOffset = { x: 0, y: 0 };
        let labelOriginalPositions = {};
        let staffLabelsState = 'off'; // 'off', 'so', 'all'
        let placedLabels = []; // Track cloned labels that were placed on notes
        let firstNote = 'so'; // Default to 'so' as first note
        let numberOfNotes = 3; // Number of notes to generate (3-6)
        let customPattern = null; // Store custom pattern if set
        let colorsEnabled = true; // Track whether colors are enabled
        let placementHistory = []; // Track order of placements for undo functionality

        // Initialize
        function init() {
            generateRandomPattern();
            drawStaff();
            setupDragAndDrop();
            updateNoteCountButton();
            updateUndoButton();
        }

        // Generate random pattern of notes
        function generateRandomPattern() {
            const notes = ['so', 'la', 'mi', 're', 'do'];
            currentPattern = [];

            // Helper function to pick a random note that's not the same as the last two
            function getNextNote() {
                const patternLength = currentPattern.length;

                // If we have at least 2 notes, check if they're the same
                if (patternLength >= 2) {
                    const lastNote = currentPattern[patternLength - 1];
                    const secondLastNote = currentPattern[patternLength - 2];

                    // If last two notes are the same, don't allow that note again
                    if (lastNote === secondLastNote) {
                        const availableNotes = notes.filter(n => n !== lastNote);
                        return availableNotes[Math.floor(Math.random() * availableNotes.length)];
                    }
                }

                // Otherwise, any random note is fine
                return notes[Math.floor(Math.random() * notes.length)];
            }

            // If first note is set, start with it
            if (firstNote) {
                currentPattern.push(firstNote);
                // Fill remaining slots
                for (let i = 1; i < numberOfNotes; i++) {
                    currentPattern.push(getNextNote());
                }
            } else {
                // Randomly select notes
                for (let i = 0; i < numberOfNotes; i++) {
                    currentPattern.push(getNextNote());
                }
            }

            console.log('Generated pattern:', currentPattern);
        }

        // Restore pattern from saved data
        function restorePattern(pattern, placements) {
            currentPattern = pattern;
            labelPlacements = placements || {};

            // Clear any existing placed labels first
            placedLabels.forEach(label => {
                if (label && label.parentNode) {
                    label.remove();
                }
            });
            placedLabels = [];
            placementHistory = []; // Clear placement history on restore

            drawStaff();

            // Recreate and position the placed labels
            Object.entries(labelPlacements).forEach(([noteIndex, labelNote]) => {
                const notePos = notePositions[noteIndex];
                if (notePos) {
                    // Create a clone of the original label from the palette
                    const originalLabel = document.querySelector(`#labelContainer [data-note="${labelNote}"]`);
                    if (originalLabel) {
                        const clone = originalLabel.cloneNode(true);
                        clone.classList.remove('dragging');
                        clone.classList.add('placed');
                        clone.style.position = 'fixed';
                        document.body.appendChild(clone);

                        // Position it on the note
                        positionLabelOnNote(clone, notePos);

                        // Track this placed label
                        placedLabels.push(clone);

                        // Add to placement history
                        placementHistory.push({
                            noteIndex: parseInt(noteIndex),
                            labelNote: labelNote,
                            labelElement: clone
                        });
                    }
                }
            });

            // Update completion indicator and undo button
            updateCompletionIndicator();
            updateUndoButton();
        }

        // Get current scale factor based on resolution mode
        function getScale() {
            return document.body.classList.contains('resolution-4k') ? 2 : 1;
        }

        // Draw staff and notes
        function drawStaff() {
            const canvas = document.getElementById('staffCanvas');
            const ctx = canvas.getContext('2d');
            const scale = getScale();

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const staffLeft = 80 * scale;  // Reduced margin to move staff left, scaled
            const staffRight = canvasWidth - (80 * scale);

            // Dynamic note radius - smaller when there are more notes (scaled)
            let noteRadius = 30 * scale;
            if (currentPattern.length > 6) {
                noteRadius = 20 * scale;
            } else if (currentPattern.length > 4) {
                noteRadius = 25 * scale;
            }

            // Three-line staff for So-La-Mi-Re-Do (scaled)
            const lineSpacing = 60 * scale;
            const soLineY = canvasHeight / 2 - lineSpacing;
            const miLineY = canvasHeight / 2;
            const doLineY = canvasHeight / 2 + lineSpacing;
            const laPosY = soLineY - noteRadius; // La touches the So line from above
            const rePosY = (miLineY + doLineY) / 2; // Re is in the space between Mi and Do

            const noteYPositions = {
                'la': laPosY,
                'so': soLineY,
                're': rePosY,
                'mi': miLineY,
                'do': doLineY
            };

            // Draw staff lines (scaled)
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3 * scale;

            // So line
            ctx.beginPath();
            ctx.moveTo(staffLeft, soLineY);
            ctx.lineTo(staffRight, soLineY);
            ctx.stroke();

            // Mi line
            ctx.beginPath();
            ctx.moveTo(staffLeft, miLineY);
            ctx.lineTo(staffRight, miLineY);
            ctx.stroke();

            // Do line
            ctx.beginPath();
            ctx.moveTo(staffLeft, doLineY);
            ctx.lineTo(staffRight, doLineY);
            ctx.stroke();

            // Draw staff labels on the left based on state
            if (staffLabelsState !== 'off') {
                ctx.font = `bold ${24 * scale}px Arial`;
                ctx.fillStyle = '#2c3e50';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                if (staffLabelsState === 'so' || staffLabelsState === 'all') {
                    ctx.fillText('So', staffLeft - (20 * scale), soLineY);
                }

                if (staffLabelsState === 'all') {
                    ctx.fillText('Mi', staffLeft - (20 * scale), miLineY);
                    ctx.fillText('Do', staffLeft - (20 * scale), doLineY);
                }
            }

            // Draw notes - dynamically space based on number of notes
            const noteSpacing = (staffRight - staffLeft) / (currentPattern.length + 1);
            notePositions = [];

            currentPattern.forEach((note, i) => {
                const xPos = staffLeft + noteSpacing * (i + 1);
                const yPos = noteYPositions[note];
                const color = colorsEnabled ? noteColors[note] : '#95a5a6'; // Use grey if colors disabled

                // Draw note circle
                ctx.fillStyle = color;
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(xPos, yPos, noteRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Store position for snap detection
                notePositions.push({
                    note: note,
                    x: xPos,
                    y: yPos,
                    radius: noteRadius,
                    index: i
                });
            });
        }

        // Setup drag and drop for labels
        function setupDragAndDrop() {
            const labels = document.querySelectorAll('.draggable-label');

            labels.forEach(label => {
                // Store original position
                const rect = label.getBoundingClientRect();
                labelOriginalPositions[label.dataset.note] = {
                    parent: label.parentElement,
                    element: label
                };

                // Mouse down
                label.addEventListener('mousedown', (e) => {
                    startDrag(label, e);
                });

                // Touch start
                label.addEventListener('touchstart', (e) => {
                    startDrag(label, e.touches[0]);
                    e.preventDefault();
                });
            });

            // Mouse move
            document.addEventListener('mousemove', (e) => {
                if (draggedLabel) {
                    drag(e);
                }
            });

            // Touch move
            document.addEventListener('touchmove', (e) => {
                if (draggedLabel) {
                    drag(e.touches[0]);
                    e.preventDefault();
                }
            }, { passive: false });

            // Mouse up
            document.addEventListener('mouseup', (e) => {
                if (draggedLabel) {
                    endDrag(e);
                }
            });

            // Touch end
            document.addEventListener('touchend', (e) => {
                if (draggedLabel) {
                    endDrag(e.changedTouches[0]);
                }
            });
        }

        function startDrag(label, event) {
            // Create a clone of the label for dragging
            const clone = label.cloneNode(true);
            clone.classList.add('dragging');
            clone.style.position = 'fixed';
            clone.style.zIndex = '1000';
            document.body.appendChild(clone);

            draggedLabel = clone;

            const rect = label.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left;
            dragOffset.y = event.clientY - rect.top;

            clone.style.left = (event.clientX - dragOffset.x) + 'px';
            clone.style.top = (event.clientY - dragOffset.y) + 'px';
        }

        function drag(event) {
            if (!draggedLabel) return;

            draggedLabel.style.left = (event.clientX - dragOffset.x) + 'px';
            draggedLabel.style.top = (event.clientY - dragOffset.y) + 'px';
        }

        function endDrag(event) {
            if (!draggedLabel) return;

            const canvas = document.getElementById('staffCanvas');
            const canvasRect = canvas.getBoundingClientRect();

            // Get label center position
            const labelRect = draggedLabel.getBoundingClientRect();
            const labelCenterX = labelRect.left + labelRect.width / 2;
            const labelCenterY = labelRect.top + labelRect.height / 2;

            // Convert to canvas coordinates
            const canvasX = labelCenterX - canvasRect.left;
            const canvasY = labelCenterY - canvasRect.top;

            // Find closest note
            let closestNote = null;
            let closestDistance = Infinity;
            const snapDistance = 80; // Snap if within 80px

            notePositions.forEach(notePos => {
                const dx = canvasX - notePos.x;
                const dy = canvasY - notePos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < closestDistance && distance < snapDistance) {
                    closestDistance = distance;
                    closestNote = notePos;
                }
            });

            if (closestNote) {
                // Remove any previous label on this note
                const previousLabel = placedLabels.find(l =>
                    labelPlacements[closestNote.index] === l.dataset.note
                );
                if (previousLabel) {
                    previousLabel.remove();
                    placedLabels = placedLabels.filter(l => l !== previousLabel);
                }

                // Snap clone to note
                draggedLabel.classList.remove('dragging');
                draggedLabel.classList.add('placed');
                positionLabelOnNote(draggedLabel, closestNote);

                // Track this placed label
                placedLabels.push(draggedLabel);

                // Record new placement
                labelPlacements[closestNote.index] = draggedLabel.dataset.note;

                // Add to placement history for undo functionality
                placementHistory.push({
                    noteIndex: closestNote.index,
                    labelNote: draggedLabel.dataset.note,
                    labelElement: draggedLabel
                });

                // Update undo button state
                updateUndoButton();

                console.log('Label placements:', labelPlacements);

                // Check if complete and notify parent
                if (checkIfComplete()) {
                    notifyParent();
                }

                // Update completion indicator
                updateCompletionIndicator();
            } else {
                // Remove the clone if not placed on a note
                draggedLabel.remove();
            }

            draggedLabel = null;
        }

        function positionLabelOnNote(label, notePos) {
            const canvas = document.getElementById('staffCanvas');
            const canvasRect = canvas.getBoundingClientRect();

            label.style.position = 'fixed';
            label.style.left = (canvasRect.left + notePos.x - label.offsetWidth / 2) + 'px';
            label.style.top = (canvasRect.top + notePos.y - label.offsetHeight / 2) + 'px';
        }



        function checkIfComplete() {
            // Check if all notes have labels
            return Object.keys(labelPlacements).length === numberOfNotes;
        }

        function updateCompletionIndicator() {
            const indicator = document.getElementById('completionIndicator');
            if (checkIfComplete()) {
                indicator.classList.add('show');
            } else {
                indicator.classList.remove('show');
            }
        }

        function getCurrentResponse() {
            // Calculate number correct
            let correct = 0;
            Object.entries(labelPlacements).forEach(([noteIndex, labelNote]) => {
                if (currentPattern[noteIndex] === labelNote) {
                    correct++;
                }
            });

            const response = {
                pattern: currentPattern,
                placements: labelPlacements,
                correct: correct,
                total: numberOfNotes
            };

            return JSON.stringify(response);
        }

        function notifyParent() {
            // Notify parent window that response is complete
            window.parent.postMessage({
                type: 'taskmodule:response',
                value: getCurrentResponse(),
                isComplete: true
            }, '*');
        }

        function resetModule() {
            // Remove all placed labels
            placedLabels.forEach(label => {
                if (label && label.parentNode) {
                    label.remove();
                }
            });

            placedLabels = [];
            labelPlacements = {};
            placementHistory = [];
            generateRandomPattern();
            drawStaff();
            updateCompletionIndicator();
            updateUndoButton();
        }

        function toggleColors() {
            colorsEnabled = !colorsEnabled;
            const btn = document.getElementById('colorToggleBtn');
            if (btn) {
                btn.textContent = colorsEnabled ? 'Colors On' : 'Colors Off';
            }
            drawStaff();
        }

        function undoLastPlacement() {
            if (placementHistory.length === 0) return;

            // Get the last placement
            const lastPlacement = placementHistory.pop();

            // Remove the label element from the DOM
            if (lastPlacement.labelElement && lastPlacement.labelElement.parentNode) {
                lastPlacement.labelElement.remove();
            }

            // Remove from placedLabels array
            placedLabels = placedLabels.filter(l => l !== lastPlacement.labelElement);

            // Remove from labelPlacements object
            delete labelPlacements[lastPlacement.noteIndex];

            // Update UI
            updateCompletionIndicator();
            updateUndoButton();

            console.log('Undone placement. Remaining placements:', labelPlacements);
        }

        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = placementHistory.length === 0;
            }
        }

        function toggleStaffLabels() {
            // Cycle through: off -> so -> all -> off
            if (staffLabelsState === 'off') {
                staffLabelsState = 'so';
            } else if (staffLabelsState === 'so') {
                staffLabelsState = 'all';
            } else {
                staffLabelsState = 'off';
            }

            drawStaff();
        }

        function refreshPattern() {
            // Simply reset to generate a new pattern
            // No need to save - the module already auto-saves on completion
            resetModule();
        }

        // Toggle note count (cycles through 3, 4, 5, 6)
        function toggleNoteCount() {
            numberOfNotes++;
            if (numberOfNotes > 6) {
                numberOfNotes = 3;
            }
            updateNoteCountButton();
            saveSettings(); // Save settings to parent
            resetModule();
        }

        function updateNoteCountButton() {
            const btn = document.getElementById('noteCountBtn');
            if (btn) {
                btn.textContent = numberOfNotes + ' Notes';
            }
        }

        // First Note Selection Modal
        function openFirstNoteSelection() {
            const radioList = document.getElementById('firstNoteRadios');
            radioList.innerHTML = '';

            // None option
            const noneDiv = document.createElement('div');
            noneDiv.className = 'radio-item';
            noneDiv.innerHTML = `
                <input type="radio" name="firstNote" id="first-none" value="none"
                       ${!firstNote ? 'checked' : ''}>
                <label for="first-none">None (Random)</label>
            `;
            radioList.appendChild(noneDiv);

            // Note options
            const notes = ['so', 'la', 'mi', 're', 'do'];
            notes.forEach(note => {
                const div = document.createElement('div');
                div.className = 'radio-item';
                div.innerHTML = `
                    <input type="radio" name="firstNote" id="first-${note}" value="${note}"
                           ${firstNote === note ? 'checked' : ''}>
                    <label for="first-${note}">${note.charAt(0).toUpperCase() + note.slice(1)}</label>
                `;
                radioList.appendChild(div);
            });

            document.getElementById('firstNoteModal').classList.add('show');
        }

        function saveFirstNote() {
            const selected = document.querySelector('input[name="firstNote"]:checked');
            if (selected) {
                firstNote = selected.value === 'none' ? null : selected.value;
            }
            saveSettings(); // Save settings to parent
            closeModal('firstNoteModal');
            resetModule();
        }

        // Custom Pattern Modal
        function openCustomPattern() {
            document.getElementById('customPatternInput').value = '';
            document.getElementById('customPatternModal').classList.add('show');
            // Focus on input field
            setTimeout(() => {
                document.getElementById('customPatternInput').focus();
            }, 100);
        }

        function parseCustomPattern(input) {
            // Remove spaces and convert to lowercase
            input = input.replace(/\s/g, '').toLowerCase();

            if (!input) {
                return null;
            }

            // Mapping from shorthand to full note names
            const noteMap = {
                's': 'so',
                'l': 'la',
                'm': 'mi',
                'r': 're',
                'd': 'do'
            };

            const pattern = [];

            for (let i = 0; i < input.length; i++) {
                const char = input[i];

                // Check if it's a valid note letter
                if (noteMap[char]) {
                    pattern.push(noteMap[char]);
                } else {
                    // Invalid character found
                    return null;
                }
            }

            return pattern.length > 0 ? pattern : null;
        }

        function applyCustomPattern() {
            const input = document.getElementById('customPatternInput').value;
            const parsed = parseCustomPattern(input);

            if (!parsed) {
                alert('Invalid pattern! Please use s, l, m, r, or d only.');
                closeModal('customPatternModal');
                return;
            }

            if (parsed.length > 12) {
                alert('Pattern too long! Maximum 12 notes.');
                closeModal('customPatternModal');
                return;
            }

            // Apply the pattern
            currentPattern = parsed;
            numberOfNotes = parsed.length;
            customPattern = input; // Save the custom pattern
            updateNoteCountButton();

            // Reset placements
            placedLabels.forEach(label => {
                if (label && label.parentNode) {
                    label.remove();
                }
            });
            placedLabels = [];
            labelPlacements = {};

            saveSettings(); // Save settings including custom pattern
            closeModal('customPatternModal');
            drawStaff();
        }

        // Handle Enter key in custom pattern input
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('customPatternInput');
            if (input) {
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        applyCustomPattern();
                    }
                });
            }
        });

        // Close modal helper
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // Listen for init message from parent
        window.addEventListener('message', (event) => {
            if (event.data.type === 'taskmodule:init') {
                // Call TaskModule.init with context and savedSettings
                window.TaskModule.init(event.data.context, event.data.savedSettings);
            }
        });
    </script>
</body>

</html>